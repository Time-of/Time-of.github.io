---
categories: [공부, 언리얼 엔진, 최적화]
tags: [언리얼 엔진, 최적화]
use_math: true
title: "[UE5/최적화] (Hierarchical) Instanced Static Mesh"
---

# 서론

언리얼 엔진 사용 개발 시 ‘ISM, HISM을 사용하면, 반복적으로 필요한 머티리얼에 대한 드로우 콜을 줄일 수 있어 최적화에 도움이 된다’ 정도만 알고 있었고, 언제 어느 상황에 필요한지, 정확히 차이점이 무엇인지는 잘 알지 못했기에, 그 정보를 알아보고자 이 포스트를 작성한다.  
<br>

씬에 무언가가 그려질 때마다 드로우 콜이 증가한다. (CPU가 GPU에게 시켜야 할 연산 작업이 증가하는 것)  

그런데 문제는, 동일한 물체를 100개 그려도 드로우 콜이 증가한다.  
이런 많은 드로우 콜은, 성능에 영향을 주기 때문에 부담이 될 수밖에 없다.  
언리얼 엔진에서는 동일한 Static Mesh 여러 개를 한꺼번에 그릴 수 있는 기능이 있다.  
<br>

# Instanced Static Mesh
Instanced Static Mesh(이하 ISM)를 사용하면 동일한 물체를 여러 개 그릴 때의 드로우 콜이 감소한다.  
<br>

메시의 정보는 모두 GPU에 이미 저장되어 있으니, 해당 정보를 토대로 GPU에게 ‘한 번에 전부 다 그려!’ 라고 명령하는 것이다. 많은 양의 정보를 각각의 인스턴스들이 공유하는 방식으로 작동한다. 그래서 각 인스턴스는 머티리얼을 공유하기 때문에, 개별 머티리얼을 가지는 것은 불가능하다.  

여기서 GPU에 추가로 전달하는 정보는 트랜스폼(위치, 회전, 크기) 정보이다. 개별 인스턴스라고 하더라도, 각각의 위치, 회전, 크기 정보는 다를 수 있기 때문이다. (막말로, 트랜스폼이 동일하다면 굳이 여러 개의 메시를 렌더링 할 필요가 없다)  
<br>

다만 주의해야 할 점이 있는데, 해당 ISM 세트 중 하나라도 렌더링되는 경우, 전체 세트가 렌더링된다. 그러므로 뭉쳐있는 소품 세트 등의 단위로 구분해서 사용하는 것이 좋다.  

> 즉, 개별 인스턴스에 대해 오클루전 컬링이 일어나지 않는다는 뜻이다.  
{: .prompt-tip }

<br>

![image](https://github.com/Time-of/Time-of.github.io/assets/83389425/2a1e78ae-6468-4fbb-a1ce-857c7cee93ba)  
위 그림은 ISM으로, 16개의 개별 인스턴스를 가지는 Cube 메시를 표현한 것이다.  
<br>

![image](https://github.com/Time-of/Time-of.github.io/assets/83389425/96d7e653-e4fa-4304-8281-f4903eeab7dd)  
평균 드로우 콜이 6.5인 것을 확인할 수 있다.  
이 상태에서, 인스턴스가 하나만 보이도록 시야를 조정해보겠다.  
<br>

![image](https://github.com/Time-of/Time-of.github.io/assets/83389425/cdccce19-cac7-4d5c-8421-35c80a56e3b5)  
시야를 왼쪽으로 틀어, 많아봐야 2개 정도의 큐브가 우측 하단에 보이도록 조정하였다.  
하지만 드로우 콜 평균이 그대로 6.5인 것을 확인할 수 있다.  
`freezerendering`을 입력해 렌더링을 동결하고 다시 원래 시야로 돌려보면, 정말 개별 인스턴스에 대한 절두체 컬링(Frustum Culling)이 이루어지지 않았다는 것을 확인해볼 수 있다.  

<br>
그리고 일반적으로는 정적(static)인 메시를 표현하기에 적합한 기능이기 때문에, 런타임 중 이동은 지양하는 것이 좋다.  

- 물론 트랜스폼 업데이트 기능이 있긴 하다  

또한, LOD가 적용되지 않는다는 특성이 있다.  


<br>

# Hierarchical Instanced Static Mesh
LOD가 존재하는 물체를 ISM으로 사용하여 드로우 콜을 줄이고자 할 때는 Hierarchical Instanced Static Mesh(이하 HISM)을 사용할 수 있다.  
<br>

기본적으로 ISM과 거의 동일하지만, 인스턴스들의 LOD를 지원한다. 따라서 거리에 따라 자동으로 LOD 메시가 적용된다.  

LOD를 지원한다는 것은, LOD를 적용하기 위해 추가적인 연산을 사용할 수 있다는 것이다.  

**즉 애초부터 가까이서 볼 수밖에 없으며 그 집합 전체가 다른 물체에 의해 가려져 컬링될 가능성이 있는 경우, LOD를 지원한다 해도 HISM보다는 ISM이 더 성능이 좋을 수 있다.**  

<br>

# 결론

하지만 **ISM이나 HISM 중 어느 것이 낫다는 것을 전체적으로 성급하게 판단할 수는 없다.** 프로젝트의 사양이나 플레이 컨셉 등에 따라 달라지기 때문이다.  

예를 들면, 빌딩이 빽빽하게 들어선 레벨의 어느 골목길에서 쓰레기 더미를 표현한다고 가정해보자.  

빌딩에 의해 가려질 일이 많고, 이 때문에 멀리서 볼 수 없으니 ISM을 선택하는 것이 맞다고 정말 판단할 수 있을까?  

게임에서 빌딩이 부서질 수 있거나, 플레이어가 하늘을 날아다닐 수 있다면?  

<br>

이렇기 때문에, ISM 또는 HISM를 선택한다면, 프로젝트 특성과 현재 상황을 고려해서 선택하는 것이 중요하겠다.  
<br>

또한, **전체 인스턴스 중 하나라도 그려진다면 전체 인스턴스가 모두 그려진다는 점을 명심하자.**  
넓은 영역에 인스턴스들을 흩뿌려놓는 형태로 사용한다면,  아무리 드로우 콜이 감소했더라도 불필요한 연산을 추가로 수행하는 것으로, 이는 래스터라이저를 더 못살게 구는 것이다.  
<br>

또한 하나의 액터가 너무 많은 ISM/HISM의 인스턴스를 가지지 않도록 주의하자.  
이 경우는 여러 액터로 분산시켜 처리하는 것이 좋을 수 있다.  
하나의 액터가 너무 많은 인스턴스를 가진다는 것은, 마치 비유하면 하나의 스레드에 연산 작업을 많이 몰아주는 것과 같다고 볼 수 있다. 연산을 분담하기 위해 멀티스레드를 사용하는 것처럼, 표현해야 할 인스턴스가 너무 많다면, 드로우 콜은 약간 늘더라도 연산 작업을 분산해주는 것이 도움이 될 수 있다.  
<br>

물론 이런 사항도 프로젝트 특성이나, 표현하고자 하는 메시(+ 머티리얼 등 기타 요소들)의 복잡도를 함께 고려해봐야 하기 때문에, 신중히 선택하거나 직접 실험해보는 것이 좋다.  
<br>


> 참고로, 총알이나 화살이 굉장히 많이 스폰된다고 해서, 총알/화살을 ISM이나 HISM을 통해 해결하는 것은 그다지 추천되지 않는다. ISM이나 HISM은 ‘벽에 꽂힌 정적 총알/화살’ 역할을 하기에 적절하다.  
>
> -   왜냐하면, 객체 하나의 위치를 바꾸기 위해 전체 객체를 다시 렌더링해야 하기 때문.  
{: .prompt-tip }  

