---
categories: [C++, 멀티스레드]
tags: [C++, 멀티스레드]
use_math: true
title: "std::atomic"
---

```cpp
#include <atomic>
```  

<br>

# 이게 뭐죠?

C++에서 ‘원자적 연산’을 가능하게 해 주는 것.  

<br>

# 원자적 연산이 뭔데요?

원자적 연산이란, **원자를 쪼갤 수 없는 것처럼, 변수에 무언가를 할당하는 작업을 단계별로 나누지 않고 한꺼번에 실행되도록 묶어주는 연산.**  

우리가 보통 `std::mutex`로 변수 값을 수정하는 경우가 있음. 이는 상호 배제 방식을 사용해 데이터 테어링이나 레이스 컨디션을 방지하는 케이스.  

원자적 연산은 애초에  

1.  메모리의 변수 값을 CPU로 보냄  
2.  CPU에서 값을 수정  
3.  수정된 결과값을 다시 메모리에 덮어씌우기  

<br>

> **즉, 원자적 연산이란…. ‘분할 불가능한’ 연산으로 수행됨을 의미한다.**
> **다시 말하면, 멀티스레딩 환경에서도 단일 연산이 중단되지 않고 완전히 실행될 수 있음을 의미한다.**
{: .prompt-tip }


<br>


# 특징

-   **분할 불가능**
    -   시작되면 중간에 다른 스레드의 개입을 받지 않고 완료됨
-   **일관성 유지**
    -   여러 스레드가 동시에 같은 데이터에 접근하더라도 데이터가 일관적임
-   **동시성 제어**
    -   상호 배제(mutex)를 사용하지 않고도 스레드 동기화가 가능
    -   이로 인해 mutex보다 오버헤드가 적어 성능 상 이점이 존재
    -   **그러나 mutex보다 오버헤드가 적을 뿐, 원자적 연산에 오버헤드는 존재함.**
        -   따라서 절대 남용 금지.

<br>

### mutex와의 비교

-   atomic은 원자적 명령을 사용하여, 보통 lock - unlock보다 오버헤드가 적음.  
-   atomic은 단순 연산에 대해 최적화되어 있으며, 요즘 CPU는 원자적 연산을 직접 지원하기도 함.  
-   mutex는 lock - unlock 과정에서 더 많은 오버헤드가 발생.  
-   mutex는 잠금 대기 중 컨텍스트 스위칭을 겪을 수 있음. 이로 인해 추가적 비용 발생이 가능함.  
-   mutex는 복잡한 데이터 구조에 적합함.  

<br>


# 사용 예시  

-   카운터 증가  
    -   서로 공유하는 카운터를 안전하게 증가시키는 경우.  
-   플래그 관리  
    -   여러 스레드에 의해 접근되는 플래그를 안전하게 변경하고 검사하는 경우.    

<br>

**이처럼 원자적 연산은 주로 기본 자료형에 대해 사용됨.**  

**`int`, `float`, `double`, `bool` 등.**  
<br>

**`std::vector`, `std::string` 등의 자료형에 원자적 연산을 수행하는 것은 권장되지 않음. 왜냐? 이런 자료구조들은 여러 부분으로 구성되어 있어, 하나의 원자적 연산으로 전체 구조를 안전하게 수정하거나 읽는 것이 어려울 수 있음.**  

-   이런 복잡한 구조는, 가능하다면 락을 사용하지 않은 lock-free 구조를 적용한 알고리즘을 사용할 수 있다. 다만, lock-free 구조는 구현하기 훨씬 복잡하고, 성능 상 이점이 확실한 경우에만 고려해야 함. 성능 상 이점이 확실하지 않은데 구현하려 하는 것은 시간 낭비일 수 있다.  

<br>


# C++ 코드  

```cpp
int main()
{
	std::atomic<int> a = 0;

	std::thread th1([&a]()->void {
		for (int i = 0; i < 1000000; ++i) ++a;
		});

	std::thread th2([&a]()->void {
		for (int i = 0; i < 1000000; ++i) ++a;
		});

	th1.join();
	th2.join();

	std::cout << a << "\\n";

	return 0;
}

```

