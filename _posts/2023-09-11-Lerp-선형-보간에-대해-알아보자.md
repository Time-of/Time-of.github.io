---
categories: [공부, 수학]
tags: [수학]
use_math: true
---
# 선형 보간
![image](https://github.com/Time-of/Time-of.github.io/assets/83389425/5eb1b0c8-4d15-4f33-a0a1-8a0a89839f78)
Lerp(Linear Interpolation)은 선형 보간이라는 용어로, 어떤 두 점(값) 사이를 일정한 비율로써 보간하는 기능이다.  
그림에 보이는대로, `0`일수록 `A`에 가깝고, `1`일수록 `B`에 가깝게 '선형'으로 보간된다.  
그래픽스에서도 널리 쓰이며, 게임을 만들 때에도 자주 쓰이고는 한다.  
<br>
음... 하지만 이렇게만 말하면 잘 와닿지 않는다.  
그렇기에 이 `Lerp()`가 어디서 튀어나왔는지 그 근간을 이해해보고자 한다.  
<br>

# Lerp의 이해
먼저 아핀 공간에 대해 알아보자.  
아핀 공간은 간단하게 말하면, 행렬 곱으로 이동(Translate) 변환을 구현하기 위해 한 차원을 늘린 가상의 공간이라 칭할 수 있겠다.  
<br>

> 때문에 2차원 공간 계산에서는 3x3 행렬을, 3차원 공간 계산에서는 4x4 행렬을 사용하게 된다. 
> 마지막 공간의 값은 항상 '1'로 고정되는 특징을 가지고 있다.
{: .prompt-tip }
<br>
## 점
아핀 공간에 놓인 어떤 점은 마지막 차원의 값이 1인 공간의 좌표이다.  
즉, 2차원 좌표를 기준으로 할 때 Z축 값이 항상 1로 고정된다.  
<br>
## 점과 점의 덧셈
아핀 공간 내의 두 점의 덧셈은 일반적으로 연산하지 않는다.  
점 + 점의 연산결과 Z축의 값이 2가 되어버리기 때문이다.  
<br>
> 2차원을 기준으로 Z축 값이 2가 되어버리면 이동 변환 행렬 적용 시 2배로 적용되는 현상이 있기 때문에, 항상 Z축의 값은 1로 고정해야 한다.
{: .prompt-info }
<br>

하지만, 두 점 $P1(x1, y1), P2(x2, y2)$에 각각 스칼라 값 a, b를 곱해 더해보자.  
<br>

$a*P1+b*P2 = (a*x1+b*y1, a*x2+b*y2, a + b)$  

<br>

Z축 좌표는 $a+b$인데, 이는 $a+b=1$을 만족하는 경우 점과 점의 덧셈이 가능함을 의미한다.  
<br>
## 직선
$a + b = 1$이므로, 이는 $b = a - 1$과 같다.  
따라서 위 식을 $a$에 관한 식으로 정리해보면,  
<br>
$a * P1 + (1 - a) * P2 = P'$
<br>
가 됨을 의미한다.  
$a = 1$을 대입해보면 결과는 $P1$이 된다.  
$a = 0$을 대입해보면 결과는 $P2$가 된다.  
$a = 0.5$를 대입해보면 결과는 $(\frac{x1 + x2}{2}, \frac{y1 + y2}{2}, 1)$로, 이는 $P1$과 $P2$의 평균값, 즉, 중앙을 의미한다.  
그 외에도 $a = 1.5$, $a = -0.5$를 입력해보면...  
<br>
![image](https://github.com/Time-of/Time-of.github.io/assets/83389425/39f1037a-9950-4716-bb09-4bab1150e828)
이런 그림이 나타나게 된다.  
<br>
식을 $a$를 기반으로 묶어보겠다.  
$a(P1-P2) = P'-P2$  
좌변은 $P2$에서 $P1$쪽으로 가는 벡터, 우변 역시 $P2$에서 새 결과값 $P'$쪽으로 가는 벡터라고 볼 수 있다.  
<br>
두 벡터가 서로 스칼라 곱으로 정의되어 있으므로, 새 결과값 $P'$은 $P1-P2$와 동일한 직선 상의 점임을 알 수 있다.  
- 즉, 두 벡터 $P1-P2$과 $P'-P2$는 평행이다.  

이로써 위에서 사용했던 방정식은 직선의 방정식임을 알게 되었다.  
<br>

# 그래서 Lerp는?
위에서는 $a$가 커질수록 $P1$에 가까워졌으나, 좀 더 직관적으로 사용하기 위해 위에서 사용했던 식을 $b$에 대해 정리해보겠다.  
$(1 - b) * P1 + b * P2 = P'$  
이렇게 하면 $b$가 커질수록 $P2$에 가까워진다.  
직선의 방정식은 1차원 공간 내에서도 성립한다.  
<br>
```cpp
float Lerp(float P1, float P2, float b)
{
    return (1 - b) * P1 + b * P2;
}
```  
<br>
여기서 변수명만 바꿔보면,  

```cpp
float Lerp(float A, float B, float T)
{
    return (1 - T) * A + T * B;
}
```  
`T`에 따라 `A`와 `B` 사이(또는 그보다 멀리)를 선형 보간하는 형태가 된다.  
<br>

```cpp
float A = 0.0f;
float B = 10.0f;

// 7 출력
std::cout << Lerp(A, B, 0.7f) << "\n";
```

