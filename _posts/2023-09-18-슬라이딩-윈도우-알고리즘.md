---
categories: [공부, 알고리즘]
tags: [알고리즘]
use_math: true
---
# 슬라이딩 윈도우 알고리즘
슬라이딩 윈도우 알고리즘은 배열 내에서 '일정한 n개의 연속된 원소'와 관련된 작업을 할 때 유용하게 사용할 수 있는 알고리즘이다.  
예를 들어, 10개의 원소를 가진 배열에서 **연속된** 3개의 합이 10 이상인 경우 등을 구한다거나, 연속된 5개가 모두 "a", "b", "c", "d", "e"가 하나씩만 포함되어 있다거나 등을 체크할 때 사용할 수 있다.  
<br>
이름이 왜 슬라이딩 윈도우일까?  
이는 작동 방식을 살펴보면 알 수 있다.  
투-포인터 알고리즘과 유사한 느낌도 든다.  
<br>
{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 } 이라는 배열이 있다고 가정하자.  
여기서 연속된 원소 3개의 곱의 총합을 구하는 문제를 푼다고 가정한다.  
슬라이딩 윈도우 알고리즘을 사용하면 다음과 같이 작동한다:  
(`[ ]` 내에 있는 원소들이 현재 루프)  
```
{ [1, 2, 3], 4, 5, 6, 7, 8, 9, 0 }  
{ 1, [2, 3, 4], 5, 6, 7, 8, 9, 0 }  
{ 1, 2, [3, 4, 5], 6, 7, 8, 9, 0 }  
{ 1, 2, 3, [4, 5, 6], 7, 8, 9, 0 }  
{ 1, 2, 3, 4, [5, 6, 7], 8, 9, 0 }  
{ 1, 2, 3, 4, 5, [6, 7, 8], 9, 0 }
{ 1, 2, 3, 4, 5, 6, [7, 8, 9], 0 }  
{ 1, 2, 3, 4, 5, 6, 7, [8, 9, 0] }    
```
보고 나니 왜 슬라이딩 윈도우라는 이름이 붙었는지 알 것 같은가?  
마치 창문을 열듯, 정해진 범위를 유지하며 단 한 번의 외부 루프를 수행한다.  
<br>

# 코드
```cpp
int main() {
    vector<int> nums { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
    
    int length = nums.size();
    
    int mult = 1;

    // 처음 값은 수동으로 구해줘야 한다
    // 혹시 nums가 3보다 적을 수도 있으니 i < length 조건도 추가
    for (int i = 0; i < 3 and i < length; ++i)
    {
        mult *= nums[i];
    }

    // 연속된 3개의 수의 곱들의 합
    // 역시 초기값은 수동으로 구해줘야 한다
    int total = mult;

    for (int i = 0; i < length - 3; ++i)
    {
        // 현재 값을 나눠준다
        // (3개의 합산을 구하는 거였다면, -= nums[i])
        mult /= nums[i];
        // 다음에 포함시킬 값을 곱해준다
        // (3개의 합산을 구하는 거였다면, += nums[i])
        mult *= nums[i + 3];

        total += mult;
    }

    cout << "연속된 3개의 수의 곱들의 합: " << total << "\n";

    return 0;
}
```
코드에서 보이듯이, `O(n)` 안에 작업을 수행할 수 있다.  
각 원소끼리의 곱을 `for`문으로 구현했다면, `k`개의 원소에 대해 수행할 경우 `O(k * n)`이 소요되니 조심!  
특히 정수의 곱/합 등은 단순 사칙연산 만으로도 내부 반복문을 사용할 필요가 없다.  
```cpp
for (int i = 0; i < length - 2; ++i)
{
	int mult = nums[i] * nums[i + 1] * nums[i + 2];
	total += mult;
}
```
이거랑 똑같은 거 아니냐고?  
맞다.  이것도 슬라이딩 윈도우 기법이다.  
그러나 두 번째 코드보다 첫 번째 코드가 더 사용하기 편한 상황이 분명히 존재하니 기억해두도록 하자. (특히 단순 정수 연산이 아닌 경우)  


