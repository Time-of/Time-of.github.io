---
categories: [공부, 알고리즘]
tags: [알고리즘]
use_math: true
---
# 에라토스테네스의 체
기본적으로 소수를 판별하는 알고리즘.  
체를 치듯이 소수가 아닌 수를 걸러내는 방식이다.  
알고리즘의 목표는 '특정 범위 내의 모든 소수를 찾아내는 것'.  
<br>

기존 소수 구하기 알고리즘과 크게 다른 점이 무엇이냐면, 소수를 자주 판별해야 하는 경우 유용할 수 있다는 점이다.  
에라토스테네스의 체는 미리 구간 내의 소수 집합을 구해놓으므로, 이미 구한 결과를 재사용할 수 있기 때문이다.  
<br>

![Sieve_of_Eratosthenes_animation](https://github.com/Time-of/Time-of.github.io/assets/83389425/8cc1c817-0798-4b28-920b-e9676725493f)  

<br>

`num`까지의 모든 소수를 구한다고 하자.  
먼저 `num`이 100이라고 가정하면, 100까지 모든 수가 소수라고 가정하고 시작하여, 소수가 아닌 수(합성수)를 전부 지워버리면 소수만 남게 된다.  
<br>

합성수를 어떻게 판별할까?  
여기서는 일반적으로 사용되는 소수 판별 알고리즘의 아이디어를 사용할 수 있다.  
> 수의 약수를 두 자연수 순서쌍으로 나타냈을 때, 순서쌍은 보통 `(k, num / k)`로 나타내어지기 때문에, 어느 하나는 제곱근보다 커야 하고, 다른 하나는 제곱근보다 작아야한다. 만약 둘 다 제곱근보다 크다면, 곱했을 때 `num`을 초과해버리고 만다. 따라서 순서쌍 중 최소 하나는 제곱근보다 작은 경우에만 나타나기 때문에, 제곱근까지만 구해도 된다.
{: .prompt-tip }  
<br>

만약 현재 수(`i`)가 소수라고 판별되었다면(`primes[i] == true`), 해당 수에 어떤 수를 곱한다면 어떤 수를 곱하던 간에 그 수는 합성수가 된다.  
따라서 `num`까지 소수에 '현재 수(`i`)의 **배수**'를 모두 소수가 아니라고 판별시킨다.  
- 위 gif 그림에서도 2의 배수, 3의 배수 ... 를 모두 지워주는 장면을 확인할 수 있다.  

이 과정을 `i`를 1씩 증가시키면서 계속해서 반복한다.  

<br>

```cpp
// num(100)까지의 소수를 구한다고 하자.
int num = 100;
vector<bool> primes = vector<bool>(num + 1, true);

// 0과 1은 소수가 아님
primes[0] = primes[1] = false;

// 일반적으로 쓰는 소수 판별용 반복문
for (int i = 2; i * i <= num; ++i)
{
	// i가 소수라면 안쪽 반복문을 실행.
	if (primes[i])
	{
		// 소수에 어떤 수를 곱하든 합성수가 된다.
		// 현재 i는 소수지만 i의 n배수(i * n)는 약수로 i를 가지고 있으므로
		//  소수가 아니다.
		// 따라서 k += i를 하며 i의 배수들을 모조리 소수가 아니라고 판별
		// i 이전까지의 자연수 배수들은 이미 검사되었으므로, i * i부터 시작할 수 있다.
		for (int k = i * i; k <= num; k += i)
		{
			primes[k] = false;
		}
	}
}
```
<br>

코드로 표현하면 위와 같이 표현할 수 있다.  
안쪽 반복문의 `k`가 `i * i`부터 시작하는데, 이는 `i` 이전까지의 자연수 배수들은 모두 검사했기 때문에 `i * i`부터 시작하도록 최적화한 것이다.  
만약 소수 판별이 자주 일어난다면, `primes`를 재사용하면 `O(1)`만에 소수 여부를 판별할 수 있겠다.  
다만 소수를 판별할 일이 별로 없다면, 기본적인 소수 판별 알고리즘을 사용하는 것이 더 좋을 수 있다. 상황에 따라 잘 판별해서 쓰면 되겠다.  
<br>

이 알고리즘의 시간 복잡도는 무려 `O(n log log n)`이라고 한다.  
로그 로그 함수는 매우 천천히 증가하여, 거의 상수 시간에 가깝다고 볼 수 있다.  
따라서 거의 `O(n)`에 가까운 시간으로 동작한다고 가정할 수 있다. (반드시 보장은 X)  

