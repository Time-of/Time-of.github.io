---
categories: [공부, CS]
tags: [CS]
use_math: true
title: "멀티스레드 프로그래밍"
---
# 멀티스레드 프로그래밍이란?

멀티스레드 프로그래밍은 한 프로세스 안에 여러 개의 스레드를 사용해 작업을 수행하도록 프로그램을 구성하는 방법이다.  
<br>

예를 들면, 음식점에서 일한다고 할 때 손님이 많다면 한 사람이 조리, 서빙 등을 모두 수행하는 것보다, 알바를 고용해 [조리 담당, 튀김 음식 조리 담당, 서빙 담당, 홀 담당]으로 나누어 작업하는 것이 더 효율적일 것이다.  

사용자 입장에서 주문하면 음식을 받아서 먹을 수 있다는 점은 똑같다는 점에서 이런 흐름이 만들어지게 된다.  
<br>

> 참고: 유니티 엔진의 ‘코루틴(Coroutine)’을 떠올리는 사람이 있을 수 있다.  
>    
> 유니티 엔진의 코루틴은 멀티스레드가 아니고, 싱글 스레드를 매우 작게 쪼개어 사용하는 방식. 따라서 `yield return null;`을 남용한다면 퍼포먼스가 저하될 수 있음.
{: .prompt-tip }

<br>


### 프로세스? 스레드?

프로세스는 가장 일반적인 정의로 ‘실행 중인 프로그램’을 뜻한다.  

우리가 만든 실행 코드, 전역 변수, 변수 등이 메모리에 프로세스라는 형태로 적재된다.  

-   메모리에 물리적 할당되는 것이 아니라, 가상 할당.  
-   물리적 메모리는 OS만 알고 있다.  

<br>

프로세스들 간에는 서로 배타적으로, 특수한 경우가 아니라면 프로세스 간 상호 간섭이 불가능.  

프로세스가 자식 프로세스를 만드는 것은 가능하다. 이 때는 계층 구조로 이루어진다.  

스레드는 프로세스 내에서 실행되고 있는 흐름의 단위. 실제로 작업을 수행한다.  

일반적으로는 한 프로그램에서 하나씩 가지고 있지만, 멀티스레딩을 통해 여러 스레드를 가질 수 있다.  
<br>

**프로세스 간 문맥 교환(Context Switch), 스레드 간 문맥 교환이 가능하다.**  

> 문맥 교환(Context Switch)이란, 한 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전 프로세스의 상태(문맥)를 보관하고 새 프로세스의 상태를 적재하는 작업.  
>    
> [문맥 교환 - 위키백과, 우리 모두의 백과사전 (wikipedia.org)](https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98)  
{: .prompt-tip }

<br>

쉽게 말하면, 현재 프로세스의 CPU 제어권을 다른 프로세스로 옮기는 과정이라 볼 수 있다.  

CPU는 어떤 프로세스가 독점할 수 없기 때문에, 한 번에 하나의 프로세스만 CPU를 사용할 수 있다. 따라서 OS가 CPU의 사용 시간을 여러 프로세스 간 공유되도록 관리해야 한다.  

이 때 OS는 현재 실행 중인 프로세스의 상태를 저장하고, 다음에 실행할 프로세스의 상태를 불러온다. 이게 바로 문맥 교환.  

이 과정이 있기 때문에 OS가 여러 프로세스를 동시에 실행하는 것처럼 보이게 되는 것이다.  

<br>

스레드 간 문맥 교환은 프로세스의 문맥 교환과는 다르다.  

스레드는 프로세스의 문맥 교환과는 다르게, 같은 프로세스 내에서 메모리와 자원을 공유하므로 상대적으로 저장하고 불러올 정보가 적다. 따라서 비용이 프로세스의 문맥 교환보다 적게 든다.  

**이런 이유로 인해, 멀티프로세싱보다 멀티스레딩이 효율적인 것!**  

-   다만, 스레드 간에 문맥 교환 오버헤드가 클 수록 멀티스레딩 효율이 저하되므로, 그 점을 꼭 고려하도록 하자.  

<br>


# 멀티스레드 프로그래밍의 필요성

멀티스레드 프로그래밍은 연산 작업을 각각의 작은 문제들로 나눠 병렬로 실행하는 식으로 성능을 크게 높일 수 있는 데 기여한다.  

또한 연산 도중 전체 프로세스가 Blocking되지 않기 때문에, 사용자에게 더 나은 경험을 제공할 수 있다.  

-   예를 들면 소켓 통신 프로그래밍을 할 때, 다음 메시지가 오기 전까지 `recv()`로 무한정 대기한다면 사용자 입장에서는 이 프로그램이 뻗어버렸다고 생각할 수도 있다. 이걸 멀티스레드를 사용해 백그라운드에서 실행한다면 더 나은 경험을 제공할 수 있다.  

<br>


# 멀티스레드 프로그래밍의 문제점

멀티스레딩이 프로그램의 성능에 크게 기여할 수 있다는 것을 알게 되었다.  

다만 멀티스레딩 시 여러 문제가 발생할 수 있는데, 크게 4가지 문제가 있다.  

멀티스레드 프로그래밍이 어렵다고 평가되는 이유 중 하나로, 이런 문제가 발생하지 않도록 구현하는 것이 상당히 어렵기 때문이다.  

<br>

### 경쟁 상태 (Race Condition)

스레드는 기본적으로 스택 영역에 저장되며, 함수 호출과 관련된 지역 변수, 리턴 주소, 매개변수 등을 저장하기 위한 자신만의 스택을 가진다.  

-   자신만의 스택을 가지기 때문에, 스택 오버플로우가 발생하는 경우 각자의 스레드에서만 발생한다.  

<br>

스레드는 코드, 데이터, BSS, 힙 영역을 다른 스레드와 공유한다.  

그러나 스레드 간 공유되는 자원을 자유롭게 접근하고 수정할 수는 없다.    

그 이유가 무엇이냐 하면, 서로 다른 스레드가 같은 자원에 동시에 접근했을 때 데이터 불일치 문제가 발생할 수 있기 때문이다.  

여러 스레드가 공유되는 리소스에 동시에 접근할 때 경쟁 상태(Race Condition)가 발생할 수 있다.  

특히 공유 메모리에 대한 경쟁 상태를 데이터 경쟁이라 하는데, 데이터 경쟁이라 함은, 여러 스레드가 공유 메모리에 동시에 접근 가능한 상태에서, Write 작업이 최소 하나의 스레드 이상에서 발생할 때 발생한다.  
<br>

![image](https://github.com/Time-of/Time-of.github.io/assets/83389425/eef896ff-d1b9-476a-9c95-aa2c56947663)  

그림을 보자.  

A 스레드는 int값을 불러와서 `+ 1` 작업을 수행해 저장한다.  

B 스레드는 int값을 불러와서 `- 1` 작업을 수행해 저장한다.  

일반적으로 생각해봤을 때, 각각의 작업을 한 번씩 수행했을 때 다음의 결과를 예상할 수 있다:  

-   0 → 1 → 0  
-   0 → -1 → 0  

<br>

하지만 스레드는 서로 비동기적으로 실행된다. 다른 스레드의 작업이 완료될 때까지 기다려주지 않는다.  

위 그림의 경우, 스레드 A가 공유 자원 `0`을 로드, 연산 후 저장하기 전에 스레드 B가 `0`을 로드해버린다. 따라서 스레드 A가 저장한 후 스레드 B가 연산 결과를 저장해버려 결과는 `-1`이 되어버린다.  

물론 이런 상황이 반드시 발생하지는 않지만, 따로 처리를 수행하지 않는 경우, 이런 식으로 스레드가 공유 자원에 대해 경쟁을 하려고 하게 되어, **어떤 한 연산이 손실되는 결과가 생길 수 있다.**  

<br>

```cpp
#include <iostream>
#include <thread>

using namespace std;

void RunA()
{
	for (int i = 0; i < 10; ++i)
	{
		cout << "스레드 A\\n";
	}
}

void RunB()
{
	for (int i = 0; i < 10; ++i)
	{
		cout << "스레드 B\\n";
	}
}

int main()
{
	thread thA(RunA);
	thread thB(RunB);

	// join은 스레드가 실행 종료될 때까지 기다리는 함수
	// thA 스레드의 작업이 완료되고 thA 스레드가 종료될 때까지 대기
	// 즉, 아래 return 0까지 가서 프로그램이 종료되지 않도록 대기해준다.
	// 메인 스레드가 종료된 후에도 스레드가 계속 실행되는 것은 비정상 상황으로 보기 때문.
	// 그래서 join()을 지우면, 예외가 발생할 것이다.
	thA.join();
	thB.join();

	return 0;
}

```

```cpp
스레드 A
스레드 A
스레드 A
스레드 A
스레드 B
스레드 B
스레드 B
스레드 B
스레드 B
스레드 B
스레드 B
스레드 B
스레드 B
스레드 B
스레드 A
스레드 A
스레드 A
스레드 A
스레드 A
스레드 A

```  

<br>

실행 결과에서 보이듯이, 스레드는 다른 스레드가 끝날 때까지 기다려주지 않고 비동기적으로 동작한다.  

<br>

```cpp
#include <iostream>
#include <thread>

using namespace std;

int sharedResourceInt = 0;

void RunA()
{
	for (int i = 0; i < 10000; ++i)
	{
		sharedResourceInt += 1;
	}
}

int main()
{
	thread thA(RunA);
	thread thB(RunA);

	thA.join();
	thB.join();

	cout << "값: " << sharedResourceInt << "\\n";

	cout << "메인 함수 종료\\n";
	return 0;
}

```  

<br>

실행 결과:  

<br>

```cpp
값: 20000
메인 함수 종료

```  

```cpp
값: 12508
메인 함수 종료

```  

0을 10000회 더하는 스레드를 2개 진행했는데, 어떨 때는 20000이, 어떨 때는 20000이 안 되는 애매한 숫자가 나타나게 된다.  

`join()`에 의해서, 메인 스레드가 끝나지 않도록 Blocking을 걸어주었는데도 예상한 값 `20000`이 나오지 않는 현상이 발생하게 된다.  

이게 바로 경쟁 상태이다. 몇몇 연산이 무시되어버릴 수 있다는 문제이다.  

<br>

더 무시무시한 점은, 언제는 정상적인 결과를 뽑아내는데, 언제는 기대하지 않은 결과, 즉 ‘버그’가 생긴다는 점이다.  

**디버깅이 굉장히 어렵다는 점을 의미한다….**  

경쟁 상태를 해결하는 방법은 추후 포스트로 작성할 예정이다.  

<br>

### 교착 상태 (Deadlock, 병목 현상)

보통 경쟁 상태를 막기 위해, mutex(mutual exclusion, 상호 배제) 같은 동기화 기법을 사용하다 보면, 새로운 문제를 만나기 쉬운데 그것이 바로 데드락(병목 현상)이다.  

교착 상태란, 여러 스레드가 **서로 상대 스레드의 작업이 끝날 때까지 동시에 기다리는 상태**를 말한다.  

**교착 상태에 빠지면 작업이 정지되어 명령 진행이 불가능해진다는 치명적인 문제가 있다.**  

<br>

왜 발생할까?  
<br>

![image](https://github.com/Time-of/Time-of.github.io/assets/83389425/9f65f1ae-2371-4005-b70b-a47234771a13)  

그림을 보자.  

A, B 둘 다 연필과 지우개가 필요하다.  

연필과 지우개는 하나씩 있고, A와 B가 가져갈 수 있다.  

A는 지금 지우개를 갖고 있고, 연필이 필요하다.  

B는 지금 연필을 갖고 있고, 지우개가 필요하다.  

<br>

A는 연필이 필요하니까, B가 연필을 다 쓰고 원래 자리에 돌려놓기를 기다린다.  

B는 지우개가 필요하니까, A가 지우개를 다 쓰고 원래 자리에 돌려놓기를 기다린다.  

따라서 서로 대기만 하게 되는 기괴한 사태가 벌어지고 만다.  

<br>

OS가 교착 상태를 해결하지 못하는 경우 → 시스템 운영자나 사용자는 작업을 교체하거나 종료 등의 외부 간섭으로 해결해야 한다.  

하나 이상의 작업에 영향을 주어 무한정 대기하게 만든다.  

이런 교착 상태가 발생하지 않도록 하려면, 모든 스레드가 정해진 순서로 자원을 획득(Acquire)해야 하며, 교착 상태 발생 시 빠져나올 수 있는 기능을 구현해두는 것이 좋다.  

-   ‘아, 쟤 대체 연필 언제까지 쓰는거야? 내가 포기한다’ 식으로, 일정 시간이 지나면 내가 가지고 있던 자원을 포기해, 상대 스레드가 자원을 확보할 수 있는 식으로 구성할 수 있다.  

<br>

물론, 교착 상태 발생 후 해결하는 것보다는 아예 교착 상태를 발생시키지 않도록 할 수도 있다. 여러 자원이 필요한 경우 하나씩 요청하지 않고, 필요한 모든 자원을 한꺼번에 요청해버리면 된다.  

다만, 교착 상태 예방은 일반적으로 회피보다 비용이 많이 들 수 있다. 예를 들면, 한 번에 하나의 스레드만 자원을 사용하도록 제한한다면 교착 상태는 발생하지 않지만, 다른 스레드들은 대기 상태가 되므로 퍼포먼스에 영향을 줄 수 있다.  

<br>

따라서, 교착 상태가 발생할 가능성이 있다는 것을 받아들이고, 교착 상태가 발생하려고 할 때 적절히 회피하는 것이 좋을 수 있다.  

-   교착 상태 탐지에 오버헤드가 발생할 수 있음  
-   자원을 언제 요청하는지 추가 정보가 필요  
-   각 스레드가 필요한 자원의 최대치를 선언해버리는 방법도 있다  
-   그 외에도 많은 방법들이 있다…  

<br>

### 테어링 (Tearing, 찢어짐)

데이터 경쟁의 특수한 상황에서 발생한다.  

-   Torn read  
    -   어떤 스레드가 메모리에 데이터의 일부만 write하고 나머지를 미처 쓰지 못한 상황에서, 다른 스레드가 이 데이터를 읽을 때 발생  
    -   두 스레드가 보는 값이 서로 달라진다.  
-   Torn write  
    -   두 스레드가 동시에 데이터에 write할 때, 두 스레드가 서로 데이터의 다른 부분을 write한 경우 발생  

<br>

### 거짓 공유 (False-Sharing)

캐시 데이터의 구조 특성으로 인해 발생하는 문제.  

실제로는 이 부분은 사용하고 있지 않은데, 사용하고 있는 것처럼 접근하지 못해 대기하게 되는 상황이다.  

<br>

캐시(cache)는 보통 캐시 라인이라는 단위로 처리된다. 캐시 라인은 흔히 최신 CPU에서 64비트로 구성되는데, 캐시 라인에 데이터에 write하려면 캐시 라인 전체를 `lock`해버려, 다른 스레드가 캐시 라인에 있는 다른 데이터에 접근하기 위해서는 캐시 라인 전체의 `lock`이 풀릴 때까지 대기해야 한다.  

데이터 구조가 저장될 메모리 영역을 명시적으로 정렬하여 캐시 라인에 걸쳐있지 않도록 하면, 여러 스레드에서 접근할 때 캐시 라인에 의해 대기하는 상황을 방지할 수 있다.  

C++에서는 alignas 키워드를 사용하여 데이터가 적절하게 정렬되도록 할 수 있다.  

<br>

# 게임에서 멀티 스레드는 어디에 쓸까?

-   애니메이션 작업만을 담당하는 애니메이션 스레드  
-   시뮬레이션 (길찾기, 건설 등)  
-   AI 작업  
-   네트워크를 통한 서버와의 통신  
-   렌더링  
-   게임 로직 스레드  

쓰려 한다면 굉장히 많은 곳에서 사용할 수 있다.  

<br>

하지만 네트워크를 제외하고, 스레드를 사용하기 적합한 모듈이라는 것을 잘 판단하여 구성하는 것이 중요할 것이다.  

