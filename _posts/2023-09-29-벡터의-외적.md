---
categories: [공부, 수학]
tags: [수학]
use_math: true
title: "[게임 프로그래밍 - 수학] 벡터의 외적"
---
# 벡터의 외적
일반적으로 3차원에서 사용되는 두 벡터 사이의 연산  
결과가 스칼라 값이었던 내적과 다르게, 외적의 결과는 벡터가 나타난다.  
<br>

벡터 $\vec{a} = (a_x, a_y, a_z)$, $\vec{b} = (b_x, b_y, b_z)$에 대해  
외적 $\vec{a} \times \vec{b} = (a_yb_z - b_ya_z, a_zb_x - b_za_x, z_xb_y - b_xa_z)$ 이다.  

<br>

외적 결과 벡터는 '$\vec{a}$와 $\vec{b}$가 함께 존재하는 평면에 수직인 벡터'이다.  

그래서인지 연산 과정에서도 외적 결과 벡터를 $\vec{c}$라고 했을 때,  
$\vec{c}$의 `x`값은 두 피연산자의 `y`와 `z`로만 연산이, `y` 값은 두 피연산자의 `x`와 `z`로만 연산이, `z` 값은 두 피연산자의 `x`와 `y`로만 연산이 이루어지는 것으로 보인다.  

실제로 `Dot(a, c) == 0`이며 `Dot(b, c) == 0`이 나온다.  
<br>

내적 때도 그러했듯 왜 저렇게 하면 새로운 수직 벡터를 뽑아낼 수 있는가는 우리가 딱히 궁금해할 필요가 없다.  
중요한 것은 <ins>외적 결과</ins> 뿐이다.  
외적 결과는 평면의 법선 벡터(노말 벡터)라고 불린다.  
2차원 상의 임의의 두 벡터를 뽑아 외적한 값은 반드시 Z축에 평행인 벡터가 나타날 것이다.  
<br>

---

# 외적의 성질
교환법칙이 성립하지 않는다.  
`Cross(a, b) != Cross(b, a)`  
이는 조금 아래에서도 다룰 내용이다.  
<br>

결합법칙이 성립하지 않는다.  
덧셈에 대해서만 분배법칙이 성립한다.  
`Cross(a, b + v) == Cross(a, b) + Cross(a, v)`  

<br>

---

# 삼각함수와의 관계
외적 결과는 두 벡터가 이루는 각도 $\theta$에 대해서 $sin$ 함수와 비례한다.  
수학에서 벡터를 배울 때 외적의 공식은 이랬었다:  
$\vec{a} \times \vec{b}=|a||b|sin\theta$  
<br>
$sin$ 0은 `0`이므로, 평행한 벡터끼리의 외적 결과는 항상 영벡터`(0, 0, 0)`가 된다.  
	-  이 성질을 이용해 두 벡터의 평행 여부를 판별하기도 한다  

<br>

또한 위 공식에 의해, 벡터 외적으로 생성된 벡터의 크기는 두 벡터로 만들어지는 평행사변형의 넓이와 동일하다.  
벡터 `b`의 끝점에서 벡터 `a`로 수직인 선분을 내렸을 때 해당 높이는 $|b|sin\theta$기 때문이다.  
이건 사인 공식을 높이에 대해 정리하면 금방 얻어낼 수 있다.  
그걸 밑변인 `a`의 크기와 곱하면, 결과적으로 $|a||b|sin\theta$가 되고, 이는 외적의 크기와 동일하다.  
이건 그냥 '아 그런 성질이 있구나' 정도로 넘어가면 될 것 같다.  

<br>

---

# 수직인 벡터가 나온다는 것
`Cross(a, b)`의 결과 벡터는 `a`와 `b` 벡터가 함께 존재하는 평면에서 수직인 벡터가 나온다고 하였다.  
이는 다시 말하면, **어떤 평면에 존재하는 점 3개만 알면, 점 3개로 벡터 2개를 만들어, 평면에 수직하는 법선 벡터를 만들어낼 수 있다는 것**이다.  
<br>

아까 외적은 교환법칙이 성립하지 않는다고 하였다.  
이는 외적 결과 벡터의 방향 때문인데, 이 방향이 <ins>왼손 좌표계인가, 오른손 좌표계인가</ins>에 따라 다르게 나타나기 때문이다.  

<br>

왼손 좌표계라면 왼손 법칙, 오른손 좌표계라면 오른손 법칙을 사용해 외적의 방향을 추측할 수 있다.  
왼손 좌표계라고 가정한다.  
<br>

![Untitled](https://github.com/Time-of/Time-of.github.io/assets/83389425/440dfa27-0704-4d0b-8a91-e353b5d96b9a)  

외적할 두 벡터 `u`, `v`에서 시작 벡터(`Cross(u, v)`라면 `u`가 시작 벡터이다)에서 왼손을 `v`에 더 가까운 방향(각도 차이가 180도 미만인 방향)으로 말아쥔다.  
이 때 왼손 엄지손가락이 있는 방향이 외적 결과 벡터의 방향이 된다.  
오른손 좌표계라면, 오른손을 해당 방향으로 말아쥐었을 때 엄지손가락의 방향이다.  
<br>

이는 어떤 대상이 왼쪽에 있는지, 오른쪽에 있는지 좌우 판별을 할 때 사용할 수 있다.  
플레이어의 forward 벡터와 대상으로 가는 벡터를 외적한다. (`Cross(forward, v)`)  
이를 `y`축 단위 벡터와 내적하면 된다.  
왼손 좌표계의 경우 `Dot(Cross(forward, v), yUnit)`이 `0`보다 크면 우측에 있음을, 0보다 작으면 좌측에 있음을 알 수 있다.  

<br>

그 외에도 카메라가 어떤 물체를 바라볼 때 회전 값(오일러)를 구하거나,  
	- 대상 방향의 단위 벡터와 윗쪽 방향의 단위 벡터를 외적하고, 그 외적 벡터와 대상 방향 단위 벡터를 외적하면 x, y, z 세 방향 모두 구할 수 있다.  
그래픽스에서 정점이 CW(시계), CCW(반시계)로 구성되었는지를 판별하여 백페이스 컬링을 하는 데에도 사용되기도 한다.  
	- 삼각형의 세 점에서 두 벡터를 만들어 외적하여 View 공간 변환 이후 카메라 시점 벡터와 내적하여 결정  
<br>

외적도 게임 프로그래머라면 항상 가까이 하는 것이 좋다.  



