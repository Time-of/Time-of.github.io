---
categories: [공부, 알고리즘]
tags: [알고리즘]
use_math: true
title: "페르마의 소정리 (그리고 % 1000000007)"
---
# 1000000007?

가끔 문제를 풀다보면, 오버플로우 방지를 위해 문제에서 `mod 1000000007`을 수행하라고 지시하는 경우가 있다.  

왜 이 수로 나눈 나머지(mod)를 사용할까?  
<br>

일단 이 수 `1000000007`(십억 칠)은 소수이다.  

보통 컴퓨터가 처리 가능한 숫자 범위를 넘어서는 큰 수를 다루기 위해 mod 연산을 사용하는데, `1000000007`로 나머지 연산을 사용하는 경우, 나머지 연산 후에도 결과값이 충분히 큰 범위 내에서 표현되게 된다.  
<br>

그리고 또 하나의 이유가 있는데, 소수로 mod 연산을 수행하면 페르마의 소정리에 따라, ‘소수 `p`와, `p`와 서로소인 정수 `a`에 대하여 `a^p`를 `p`로 나눈 나머지가 `a`’ 라는 성질이 성립하여 **원래 수로 복원하는 것이 가능**해진다.  

-   `a`가 2고, `p`가 소수인 5라고 할 때, 2의 5승은 32이며, 32를 5로 나눈 나머지는 2가 된다.  
<br>

이렇게 크게 두 가지 이유로 1000000007로의 모듈러 연산을 수행하는 것이다.  

<br>


# 페르마의 소정리

페르마의 소정리는 간단히 말해서  
<br>

모든 정수 `a`, 소수 `p`에 대하여 (단, `a`는 `p`의 배수가 아님 == `a`와 `p`는 서로소)  

`a^p % p == a`  

또는  

`a^(p-1) % p == 1`  

이라는 의미이다.  
<br>

여기서 아래 식의 양변에 `a^-1`을 곱해주면,  

`a^(p-2) % p == a^-1`  

이 식에 따르면, `a^(p-2) % p`는 `1/a`와 동일하다는 의미이다.  
<br>

즉, 페르마의 정리를 이용해 정수 `a`의 역수인 `1/a`를 `p`로 나눈 나머지를 구하는 것이 가능해진다.  

**즉, `a`의 모듈로 역수를 구하는 것이 가능해진다.**  

모듈로 역수를 코드로 표현하면,  
<br>

```cpp
#define mod 1000000007;

unsigned long long Pow(unsigned long long n, unsigned long long x)
{
    if (x == 0) return 1;
    
    unsigned long long result = Pow(n, x / 2) % mod;
    result = result * result % mod;
    
    if (x % 2 == 0) return result % mod;
    else return result * n % mod;
}

// 조건: n은 mod의 배수가 아님
unsigned long long ModInv(unsigned long long n)
{
    return Pow(n, mod - 2);
}

```

가 된다.  
<br>


# 모듈로 역수를 왜 쓸까

일반적으로 암호학에서 쓴다고 한다  

하지만 문제 푸는 입장에서는 왜 쓸까?  
<br>

조합을 구할 때, nCr = n! / ((n-r)! * (r!))로 구할 수 있다.  

다만, 결과를 mod연산할 때 오차가 발생할 수 있다.  

당장 5C2를 mod 13한다고 가정해보자.  

원래 5C2를 계산하고 mod 13하면, 10 % 13 == 10이 되어야 할 것이다.  

답을 구하는 과정을 보자.  
<br>

`120 / (2 * 6) % 13` 하면 `10`이 정상적으로 나온다.  

하지만 매우 큰 수에 대해서 수행하기 때문에, 오버플로우가 발생할 수밖에 없다.  

따라서 아마 이렇게 할 것이다.  
<br>

`fac[5] % mod / (fac[2] % mod * fac[3] % mod) % mod`  

하지만 실제로 해 보면?  

10이 나오지 않고, 0.5가 나와버린다.  

`n`이나 `r`이 매우 큰 값이라면, `n!`값 뿐만 아니라 `(n - r)! * r!`의 값도 매우 커진다.  

큰 수에 대해 mod를 먼저 수행하면 방금 결과처럼 계산이 정상적으로 되지 않을 수 있다.  
<br>

이렇듯 나눗셈에서 오차가 발생하는데, 이를 해결하기 위해, 모듈로 역수를 구하고, 역수를 곱해주는 방식으로 해결할 수 있다. 역수를 ‘곱’하는 것은 나눗셈으로 인한 오차가 발생하지 않기 때문.  

